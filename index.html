<!DOCTYPE html>
<html>
<head>
    <title>Interactive Map with Location Tracking</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        nav {
            position: fixed;
            top: 0;
            width: 100%;
            background: #333;
            padding: 1rem;
            z-index: 1000;
        }

        nav a {
            color: white;
            margin: 0 1rem;
            text-decoration: none;
        }

        .main-content {
            display: flex;
            margin-top: 60px;
            height: calc(100vh - 70px);
        }

        #map {
            flex: 3;
            height: 100%;
        }

        .location-list {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            border-left: 2px solid #ccc;
        }

        .location-item {
            display: grid;
            grid-template-columns: 30px 2fr 1fr 1fr 60px;
            gap: 0.5rem;
            padding: 0.5rem;
            border-bottom: 1px solid #eee;
        }

        .delete-btn {
            background: #ff4444;
            color: white;
            border: none;
            padding: 0.2rem 0.5rem;
            cursor: pointer;
        }

        /* Number labels above markers */
        .leaflet-tooltip.marker-label {
            background: #fff;
            border: 1px solid #333;
            color: #000;
            font-weight: bold;
            border-radius: 12px;
            padding: 2px 6px;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }

        /* Arrow markers between segments */
        .arrow-icon {
            width: 24px;
            height: 24px;
            pointer-events: none;
            display: block;
        }
        .arrow-icon .arrow-wrap {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: 50% 50%;
        }
        .arrow-icon svg {
            width: 18px;
            height: 18px;
            display: block;
        }

        footer {
            position: fixed;
            bottom: 0;
            width: 100%;
            background: #333;
            color: white;
            padding: 1rem;
            display: flex;
            justify-content: space-around;
        }

        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 2rem;
            z-index: 1001;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
        }
		
        #clearAllBtn {
            margin-bottom: 1rem;
            width: 100%;
            padding: 0.5rem;
            background: #ff4444;
            color: white;
            border: none;
            cursor: pointer;
        }

        #clearAllBtn:hover {
            background: #cc0000;
        }

        #toggleList {
            margin-bottom: 1rem;
            width: 100%;
            padding: 0.5rem;
            background: #ff4444;
            color: white;
            border: none;
            cursor: pointer;
        }

        #toggleList:hover {
            background: #cc0000;
        }

		#loadGpxBtn {
			background: #007bff;
			color: white;
			margin-bottom: 1rem;
			cursor: pointer;
			padding: 0.5rem;
		}

		#loadGpxBtn:hover {
			background: #0056b3;
		}		

        .leaflet-grid-label {
  			.grid-label-100k {
    			background-color: yellow;
    			font-size: 13px;
    			opacity: 0.6;
    			color: red;
    			position: relative;
    			display: inline;
    			padding: 1.75px;
    			border: 1px black solid;
    			border-radius: 2px;
  			}
  			.grid-label-1000m {
    			background-color: yellow;
    			font-size: larger;
    			font-weight: bold;
    			opacity: 0.8;
    			color: black;
    			text-align: center;
    			position: relative;
    			display: inline;
    			padding: 5px;
    			border-radius: 50%;
  			}
			}
    </style>
</head>
<body>
    <nav>
        <a href="#resources">Resources</a>
        <a href="#maps">Maps</a>
        <a href="#tools">Tools</a>
        <select id="coordFormat" style="margin-left:1rem;">
            <option value="DD">Decimal Degrees (DD)</option>
            <option value="MGRS">Military Grid Reference System (MGRS)</option>
        </select>
        <button id="exportBtn" style="margin-left:1rem;">Export CSV</button>
        <label style="margin-left:0.5rem; color:#fff; font-weight:normal;">
            <input type="checkbox" id="showMarkerLabels" style="margin-left:0.35rem;" checked> Show marker
        </label>
		<button onclick="showHideLocationList()">Hide/Show List</button>
        <span id="mouseCoordinates" style="margin-left:1rem; color:#fff; font-family:monospace; font-size:14px;"></span>
    </nav>

    <div class="main-content">
        <div id="map"></div>
        <div class="location-list" id="location-list">
			<button id="loadGpxBtn" style="margin-bottom: 1rem; width: 100%; padding: 0.5rem; background: #007bff; color: white; border: none; cursor: pointer;">Load GPX File</button>
			<input type="file" id="gpxInput" style="display: none;" accept=".gpx" />
		    <button id="clearAllBtn">Clear All Markers</button>
            <div id="locationList"></div>
                <div id="totalDistance">Total Distance: 0.00 km</div>
        </div>
    </div>



    <div class="modal-overlay" id="modalOverlay"></div>
    <div class="modal" id="contactModal">
        <h2>Contact Us</h2>
        <form>
            <input type="text" placeholder="Name" required>
            <input type="email" placeholder="Email" required>
            <textarea placeholder="Message" required></textarea>
            <button type="submit">Send</button>
        </form>
    </div>

    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/mgrs/dist/mgrs.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.7.5/dist/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/proj4leaflet@1.0.2/src/proj4leaflet.js"></script>
    <!-- proj4 removed; HK80 conversion removed -->
    <script>

        let map;
        let markers = [];
        let polyline = null;
        let arrowMarkers = []; // markers for arrow heads between segments
        let mgrsGridLayer = null; // MGRS grid layer

        // proj4 definition for HK1980 / TM (EPSG:2326)
        // proj4/EPSG helpers removed with HK80 conversion

        // HK80 conversion removed; app now uses Decimal Degrees only.

        /**
         * Convert WGS84 lat/lng to HK 1-km grid reference (HK1980 Grid System)
         * Uses proj4 to transform to EPSG:2326, rounds to nearest km, and
         * computes the official two-letter prefix using fixed offsets. The
         * offsets were chosen to align with the HK 1-km lettering layout so
         * typical Hong Kong coordinates map as expected (e.g., 22.3666,114.1564 => KK 293 792).
         */
        // HK80 gridding logic removed

        // HK80 conversion wrapper removed

        // proj4-based HK80 conversion removed

        // Custom HK1980 fallback removed

        function getSelectedFormat() {
            const sel = document.getElementById('coordFormat');
            return sel ? sel.value : 'DD';
        }
        function initCoordFormatListener() {
            const sel = document.getElementById('coordFormat');
            if (sel) sel.addEventListener('change', () => {
                updateLocationList();
                toggleMGRSGrid();
            });
        }

        function updateMouseCoordinates(latlng) {
            const display = document.getElementById('mouseCoordinates');
            if (!display) return;

            const format = getSelectedFormat();
            let coordText = '';

            if (format === 'MGRS') {
                try {
                    // Use 1-km precision (3 digits) and format as: "50Q KK 229 779"
                    const raw = mgrs.forward([latlng.lng, latlng.lat], 3);
                    const prefix = raw.slice(0, 3);
                    const square = raw.slice(3, 5);
                    const rest = raw.slice(5);
                    const half = rest.length / 2;
                    const easting = rest.slice(0, half);
                    const northing = rest.slice(half);
                    coordText = `${prefix} ${square} ${easting} ${northing}`;
                } catch (e) {
                    coordText = 'N/A';
                }
            } else {
                // DD format
                coordText = `${latlng.lat.toFixed(6)}, ${latlng.lng.toFixed(6)}`;
            }

            display.textContent = coordText;
        }

        function toggleMGRSGrid() {
            const format = getSelectedFormat();
            if (format === 'MGRS') {
                // Add MGRS grid if not already added
                if (!mgrsGridLayer) {
                    mgrsGridLayer = L.layerGroup();
                    drawMGRSGrid();
                    mgrsGridLayer.addTo(map);
                    // Redraw grid when map moves or zooms
                    map.on('moveend zoomend', drawMGRSGrid);
                }
            } else {
                // Remove MGRS grid if it exists
                if (mgrsGridLayer) {
                    map.off('moveend zoomend', drawMGRSGrid);
                    map.removeLayer(mgrsGridLayer);
                    mgrsGridLayer = null;
                }
            }
        }

        function drawMGRSGrid() {
            if (!mgrsGridLayer || typeof mgrs === 'undefined') return;
            
            mgrsGridLayer.clearLayers();
            
            const bounds = map.getBounds();
            const zoom = map.getZoom();
            const center = bounds.getCenter();
            
            // Only display grid for Hong Kong region (approximately)
            const HK_LAT_MIN = 21.5;
            const HK_LAT_MAX = 23.5;
            const HK_LNG_MIN = 113.0;
            const HK_LNG_MAX = 115.0;
            
            if (center.lat < HK_LAT_MIN || center.lat > HK_LAT_MAX || 
                center.lng < HK_LNG_MIN || center.lng > HK_LNG_MAX) {
                return; // Outside Hong Kong region, don't draw grid
            }
            
            // Determine grid size based on zoom level
            let gridInterval = 100000; // 100km default
            if (zoom >= 7) gridInterval = 100000; // 100km
            if (zoom >= 9) gridInterval = 10000; // 10km
            if (zoom >= 11) gridInterval = 1000; // 1km
            
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();
            
            try {
                // Get center point MGRS to determine the grid zone
                const centerMGRS = mgrs.forward([center.lng, center.lat]);
                const gridZone = centerMGRS.substring(0, 5); // e.g., "50QKK"
                
                // Calculate actual visible area dimensions for dynamic margin
                const latRange = ne.lat - sw.lat;
                const lngRange = ne.lng - sw.lng;
                const latMargin = latRange * 1.0; // 100% margin
                const lngMargin = lngRange * 1.0;
                
                // Sample multiple points across the visible area to handle all cases
                const samplePoints = [
                    [sw.lng, sw.lat], // Southwest
                    [ne.lng, ne.lat], // Northeast
                    [sw.lng, ne.lat], // Northwest
                    [ne.lng, sw.lat], // Southeast
                    [center.lng, center.lat], // Center
                    [sw.lng - lngMargin, sw.lat - latMargin], // Extended SW
                    [ne.lng + lngMargin, ne.lat + latMargin], // Extended NE
                ];
                
                // Extract easting and northing from MGRS string
                const getEN = (mgrsStr) => {
                    const e = parseInt(mgrsStr.substring(5, 10) || '0');
                    const n = parseInt(mgrsStr.substring(10, 15) || '0');
                    return { e, n };
                };
                
                // Collect all easting and northing values from sample points
                let minE = Infinity, maxE = -Infinity, minN = Infinity, maxN = -Infinity;
                
                for (const [lng, lat] of samplePoints) {
                    try {
                        const pointMGRS = mgrs.forward([lng, lat]);
                        const en = getEN(pointMGRS);
                        minE = Math.min(minE, en.e);
                        maxE = Math.max(maxE, en.e);
                        minN = Math.min(minN, en.n);
                        maxN = Math.max(maxN, en.n);
                    } catch (err) {
                        // Skip points that fail conversion
                    }
                }
                
                // Round to grid intervals with buffer
                minE = Math.floor(minE / gridInterval) * gridInterval - gridInterval;
                maxE = Math.ceil(maxE / gridInterval) * gridInterval + gridInterval;
                minN = Math.floor(minN / gridInterval) * gridInterval - gridInterval;
                maxN = Math.ceil(maxN / gridInterval) * gridInterval + gridInterval;
                
                const drawnEastings = new Set();
                const drawnNorthings = new Set();
                
                // Draw vertical grid lines (constant easting)
                for (let e = minE; e <= maxE; e += gridInterval) {
                    if (drawnEastings.has(e)) continue;
                    drawnEastings.add(e);
                    
                    const points = [];
                    // Increase sampling density for better line coverage
                    const step = gridInterval / 20;
                    for (let n = minN; n <= maxN; n += step) {
                        try {
                            const eStr = String(e).padStart(5, '0');
                            const nStr = String(n).padStart(5, '0');
                            const testMGRS = gridZone + eStr + nStr;
                            const pt = mgrs.toPoint(testMGRS);
                            
                            // Check if point is within extended bounds
                            if (pt[1] >= sw.lat - latMargin && pt[1] <= ne.lat + latMargin && 
                                pt[0] >= sw.lng - lngMargin && pt[0] <= ne.lng + lngMargin) {
                                points.push([pt[1], pt[0]]);
                            }
                        } catch (err) {
                            // Silently continue on conversion errors
                        }
                    }
                    
                    if (points.length >= 2) {
                        const line = L.polyline(points, { color: '#D00000', weight: 1, opacity: 0.6 });
                        mgrsGridLayer.addLayer(line);
                        
                        // Find point closest to top edge that's within visible bounds
                        let topmostPoint = null;
                        let maxLat = -Infinity;
                        for (const pt of points) {
                            // Check if point is within visible bounds (not extended)
                            if (pt[1] >= sw.lng && pt[1] <= ne.lng && pt[0] >= sw.lat && pt[0] <= ne.lat) {
                                if (pt[0] > maxLat) {
                                    maxLat = pt[0];
                                    topmostPoint = pt;
                                }
                            }
                        }
                        
                        // Show label if we have a visible point
                        if (topmostPoint) {
                            const labelValue = e / 1000;
                            const labelText = labelValue < 10 ? `0${labelValue}` : String(labelValue);
                            const label = L.marker(topmostPoint, {
                                icon: L.divIcon({
                                    className: 'mgrs-grid-label',
                                    html: `<div style="font-size:10px; color:#D00000; font-weight:bold; background:rgba(255,255,255,0.95); padding:2px 4px; border:1px solid #D00000; white-space:nowrap; border-radius:2px;">${labelText}</div>`,
                                    iconSize: [40, 16],
                                    iconAnchor: [20, -5]
                                }),
                                interactive: false
                            });
                            mgrsGridLayer.addLayer(label);
                        }
                    }
                }
                
                // Draw horizontal grid lines (constant northing)
                for (let n = minN; n <= maxN; n += gridInterval) {
                    if (drawnNorthings.has(n)) continue;
                    drawnNorthings.add(n);
                    
                    const points = [];
                    // Increase sampling density for better line coverage
                    const step = gridInterval / 20;
                    for (let e = minE; e <= maxE; e += step) {
                        try {
                            const eStr = String(e).padStart(5, '0');
                            const nStr = String(n).padStart(5, '0');
                            const testMGRS = gridZone + eStr + nStr;
                            const pt = mgrs.toPoint(testMGRS);
                            
                            // Check if point is within extended bounds
                            if (pt[1] >= sw.lat - latMargin && pt[1] <= ne.lat + latMargin && 
                                pt[0] >= sw.lng - lngMargin && pt[0] <= ne.lng + lngMargin) {
                                points.push([pt[1], pt[0]]);
                            }
                        } catch (err) {
                            // Silently continue on conversion errors
                        }
                    }
                    
                    if (points.length >= 2) {
                        const line = L.polyline(points, { color: '#D00000', weight: 1, opacity: 0.6 });
                        mgrsGridLayer.addLayer(line);
                        
                        // Find point closest to left edge that's within visible bounds
                        let leftmostPoint = null;
                        let minLng = Infinity;
                        for (const pt of points) {
                            // Check if point is within visible bounds (not extended)
                            if (pt[1] >= sw.lng && pt[1] <= ne.lng && pt[0] >= sw.lat && pt[0] <= ne.lat) {
                                if (pt[1] < minLng) {
                                    minLng = pt[1];
                                    leftmostPoint = pt;
                                }
                            }
                        }
                        
                        // Show label if we have a visible point
                        if (leftmostPoint) {
                            const labelValue = n / 1000;
                            const labelText = labelValue < 10 ? `0${labelValue}` : String(labelValue);
                            const label = L.marker(leftmostPoint, {
                                icon: L.divIcon({
                                    className: 'mgrs-grid-label',
                                    html: `<div style="font-size:10px; color:#D00000; font-weight:bold; background:rgba(255,255,255,0.95); padding:2px 4px; border:1px solid #D00000; white-space:nowrap; border-radius:2px;">${labelText}</div>`,
                                    iconSize: [40, 16],
                                    iconAnchor: [-5, 8]
                                }),
                                interactive: false
                            });
                            mgrsGridLayer.addLayer(label);
                        }
                    }
                }
                
            } catch (e) {
                console.error('Error drawing MGRS grid:', e);
            }
        }

        function initMap() {
            map = L.map('map').setView([22.350076, 114.158249], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            
            map.on('click', function(e) {
                const newMarker = L.marker(e.latlng);
                const checkbox = document.getElementById('showMarkerLabels');
                const show = checkbox ? checkbox.checked : true;
                if (show) {
                    newMarker.addTo(map);
                }
                markers.push(newMarker);
                updatePolyline();
                updateLocationList();
                updateTotalDistance();
            });

            // Add mousemove event to update coordinate display
            map.on('mousemove', function(e) {
                updateMouseCoordinates(e.latlng);
            });

            // Clear coordinate display when mouse leaves map
            map.on('mouseout', function() {
                const display = document.getElementById('mouseCoordinates');
                if (display) display.textContent = '';
            });
        }

        function updatePolyline() {
            // remove existing polyline
            if (polyline) {
                try { map.removeLayer(polyline); } catch (e) {}
                polyline = null;
            }
            // remove existing arrow markers
            arrowMarkers.forEach(am => { try { map.removeLayer(am); } catch (e) {} });
            arrowMarkers = [];

            if (markers.length > 1) {
                const latlngs = markers.map(marker => marker.getLatLng());
                polyline = L.polyline(latlngs, {color: 'blue'}).addTo(map);

                // create arrow markers for each segment
                for (let i = 0; i < latlngs.length - 1; i++) {
                    const a = latlngs[i];
                    const b = latlngs[i+1];
                    const midLat = (a.lat + b.lat) / 2;
                    const midLng = (a.lng + b.lng) / 2;
                    const mid = L.latLng(midLat, midLng);
                    const bearing = calculateBearing(a, b);

                    // small SVG triangle pointing up; we'll rotate the wrapper to bearing
                    const svg = `<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2 L22 22 L2 22 Z" fill="blue"/></svg>`;
                    const html = `<div class=\"arrow-wrap\" style=\"transform:rotate(${bearing}deg);\">${svg}</div>`;
                    const icon = L.divIcon({ className: 'arrow-icon', html, iconSize: [24,24], iconAnchor: [12,12] });

                    const arrow = L.marker(mid, { icon: icon, interactive: false });
                    arrow.addTo(map);
                    arrowMarkers.push(arrow);
                }
            }
        }

        function haversine(point1, point2) {
            const R = 6371;
            const dLat = (point2.lat - point1.lat) * Math.PI / 180;
            const dLon = (point2.lng - point1.lng) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(point1.lat * Math.PI / 180) * 
                Math.cos(point2.lat * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        function calculateBearing(point1, point2) {
            const lat1 = point1.lat * Math.PI / 180;
            const lon1 = point1.lng * Math.PI / 180;
            const lat2 = point2.lat * Math.PI / 180;
            const lon2 = point2.lng * Math.PI / 180;

            const y = Math.sin(lon2 - lon1) * Math.cos(lat2);
            const x = Math.cos(lat1) * Math.sin(lat2) -
                    Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
            let bearing = Math.atan2(y, x);
            bearing = bearing * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        async function updateLocationList() {
            const locationList = document.getElementById('locationList');
            locationList.innerHTML = '';
            const format = getSelectedFormat();

            // For HK80, we will gather conversion promises and update each row when ready
            const conversions = [];

            markers.forEach((marker, index) => {
                const div = document.createElement('div');
                div.className = 'location-item';
                const latLng = marker.getLatLng();
                
                let distance = '';
                let bearing = '';
                if (index > 0) {
                    const prev = markers[index-1].getLatLng();
                    distance = haversine(prev, latLng).toFixed(2) + ' km';
                    bearing = Math.round(calculateBearing(prev, latLng)) + '°';
                }

                // Compute coordinate display (Decimal Degrees or MGRS)
                let coordDisplay;
                if (format === 'MGRS' && typeof mgrs !== 'undefined') {
                    try {
                        // Use 1-km precision (3 digits) and format as: "50Q KK 229 779"
                        const raw = mgrs.forward([latLng.lng, latLng.lat], 3); // e.g., '50QKK229779'
                        const prefix = raw.slice(0, 3);
                        const square = raw.slice(3, 5);
                        const rest = raw.slice(5);
                        const half = rest.length / 2;
                        const easting = rest.slice(0, half);
                        const northing = rest.slice(half);
                        coordDisplay = `${prefix} ${square} ${easting} ${northing}`;
                    } catch (e) {
                        coordDisplay = `${latLng.lat.toFixed(6)}, ${latLng.lng.toFixed(6)}`;
                    }
                } else {
                    coordDisplay = `${latLng.lat.toFixed(6)}, ${latLng.lng.toFixed(6)}`;
                }

                div.innerHTML = `
                    <div>${index + 1}</div>
                    <div>${coordDisplay}</div>
                    <div>${distance}</div>
                    <div>${bearing}</div>
                    <button class="delete-btn" data-index="${index}">Delete</button>
                `;

                div.querySelector('.delete-btn').addEventListener('click', () => {
                    deleteMarker(index);
                });

                locationList.appendChild(div);

                // Ensure marker shows its list index above the marker, respecting the show/hide checkbox
                const showLabels = document.getElementById('showMarkerLabels') ? document.getElementById('showMarkerLabels').checked : true;
                if (marker.getTooltip && marker.getTooltip()) {
                    marker.getTooltip().setContent(String(index + 1));
                    if (showLabels) marker.openTooltip(); else marker.closeTooltip();
                } else {
                    marker.bindTooltip(String(index + 1), {
                        permanent: true,
                        direction: 'top',
                        className: 'marker-label',
                        offset: [0, -10]
                    });
                    if (showLabels) marker.openTooltip();
                }
            });

            // Optionally wait for all conversions to complete (not required for rendering)
            try { await Promise.all(conversions); }
            catch (e) { /* ignore per-row errors */ }
        }

        function deleteMarker(index) {
            map.removeLayer(markers[index]);
            markers.splice(index, 1);
            updatePolyline();
            updateLocationList();
            updateTotalDistance();
        }

        function updateTotalDistance() {
            let total = 0;
            for (let i = 1; i < markers.length; i++) {
                total += haversine(
                    markers[i-1].getLatLng(),
                    markers[i].getLatLng()
                );
            }
            document.getElementById('totalDistance').textContent = 
                `Total Distance: ${total.toFixed(2)} km`;
        }

        function openModal() {
            document.getElementById('modalOverlay').style.display = 'block';
            document.getElementById('contactModal').style.display = 'block';
        }

        document.getElementById('clearAllBtn').addEventListener('click', clearAllMarkers);

        function clearAllMarkers() {
            // Remove all markers from the map
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            
            // Remove polyline
            if (polyline) {
                map.removeLayer(polyline);
                polyline = null;
            }

            // Remove arrow markers
            arrowMarkers.forEach(am => { try { map.removeLayer(am); } catch (e) {} });
            arrowMarkers = [];

            // Update UI
            updateLocationList();
            updateTotalDistance();
        }

        function updateMarkerLabelsVisibility() {
            const checkbox = document.getElementById('showMarkerLabels');
            const show = checkbox ? checkbox.checked : true;
            markers.forEach((marker, idx) => {
                if (show) {
                    // Show marker on map
                    if (!map.hasLayer(marker)) {
                        marker.addTo(map);
                    }
                    // Show tooltip with number
                    if (marker.getTooltip && marker.getTooltip()) {
                        marker.getTooltip().setContent(String(idx + 1));
                        marker.openTooltip();
                    } else {
                        marker.bindTooltip(String(idx + 1), {
                            permanent: true,
                            direction: 'top',
                            className: 'marker-label',
                            offset: [0, -10]
                        }).openTooltip();
                    }
                } else {
                    // Hide marker from map
                    if (map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                }
            });
        }

        window.onload = function() {
                initMap();
                initCoordFormatListener();
                toggleMGRSGrid(); // Initialize grid based on default format

                // Hook up show/hide marker labels checkbox
                const lblBox = document.getElementById('showMarkerLabels');
                if (lblBox) {
                    lblBox.addEventListener('change', () => updateMarkerLabelsVisibility());
                }
        };
        document.getElementById('modalOverlay').addEventListener('click', () => {
            document.getElementById('modalOverlay').style.display = 'none';
            document.getElementById('contactModal').style.display = 'none';
        });
		
    document.getElementById('loadGpxBtn').addEventListener('click', function () {
        document.getElementById('gpxInput').click(); // Trigger file selector
    });

    document.getElementById('gpxInput').addEventListener('change', function (event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            const gpxContent = e.target.result;

            // Parse GPX file content
            const parser = new DOMParser();
            const gpxDoc = parser.parseFromString(gpxContent, 'application/xml');
            const trkpts = gpxDoc.getElementsByTagName('trkpt');

            if (trkpts.length === 0) {
                alert('No coordinates found in GPX file.');
                return;
            }

            // Clear existing markers and polylines
            clearAllMarkers();

            // Process GPX coordinates
            const points = [];
            for (let i = 0; i < trkpts.length; i++) {
                const lat = parseFloat(trkpts[i].getAttribute('lat'));
                const lon = parseFloat(trkpts[i].getAttribute('lon'));
                points.push({ lat, lon });
            }

            // Mark start and end points
            const startPoint = points[0];
            const endPoint = points[points.length - 1];
            const startMarker = L.marker([startPoint.lat, startPoint.lon]).addTo(map).bindPopup('Start Point');
            const endMarker = L.marker([endPoint.lat, endPoint.lon]).addTo(map).bindPopup('End Point');
            markers.push(startMarker, endMarker);
            // Show numbered labels and update list for the GPX points
            updateLocationList();
            updateTotalDistance();

            // Draw polyline
            if (points.length > 1) {
                const latlngs = points.map(p => [p.lat, p.lon]);
                polyline = L.polyline(latlngs, { color: 'blue' }).addTo(map);
            }

            // Calculate total distance
            let totalDistance = 0;
            for (let i = 1; i < points.length; i++) {
                const distance = haversine2(points[i - 1], points[i]);
                totalDistance += distance;
            }

            // Update total distance display
            document.getElementById('totalDistance').textContent = `Total Distance: ${totalDistance.toFixed(2)} km`;

            // Update the map view to fit the bounds of the GPX route
            if (points.length > 0) {
                const bounds = L.latLngBounds(points.map(p => [p.lat, p.lon]));
                map.fitBounds(bounds);
            }
        };

        reader.onerror = function () {
            alert('Failed to read GPX file.');
        };

        reader.readAsText(file);
    });

    // Export CSV button handler
    document.getElementById('exportBtn').addEventListener('click', function () {
        exportRouteCSV();
    });

    // HK80 test harness removed

    function exportRouteCSV() {
        const format = getSelectedFormat();
        // Use UTF-8 BOM for Excel compatibility
        let csv = '\uFEFFIndex,Coordinate,Distance,Bearing\n';

        if (format === 'MGRS') {
            for (let i = 0; i < markers.length; i++) {
                const m = markers[i];
                const latLng = m.getLatLng();
                let coord = '';
                if (typeof mgrs !== 'undefined') {
                    try {
                        const raw = mgrs.forward([latLng.lng, latLng.lat], 3);
                        const prefix = raw.slice(0, 3);
                        const square = raw.slice(3, 5);
                        const rest = raw.slice(5);
                        const half = rest.length / 2;
                        const easting = rest.slice(0, half);
                        const northing = rest.slice(half);
                        coord = `${prefix} ${square} ${easting} ${northing}`;
                    } catch (e) { coord = `${latLng.lat.toFixed(6)}, ${latLng.lng.toFixed(6)}`; }
                } else {
                    coord = `${latLng.lat.toFixed(6)}, ${latLng.lng.toFixed(6)}`;
                }
                let distance = '';
                let bearing = '';
                if (i > 0) {
                    const prev = markers[i - 1].getLatLng();
                    distance = haversine(prev, latLng).toFixed(2) + ' km';
                    bearing = Math.round(calculateBearing(prev, latLng)) + '°';
                }
                csv += `${i + 1},"${coord}",${distance},${bearing}\n`;
            }
        } else {
            for (let i = 0; i < markers.length; i++) {
                const m = markers[i];
                const latLng = m.getLatLng();
                const coord = `${latLng.lat.toFixed(6)}, ${latLng.lng.toFixed(6)}`;
                let distance = '';
                let bearing = '';
                if (i > 0) {
                    const prev = markers[i - 1].getLatLng();
                    distance = haversine(prev, latLng).toFixed(2) + ' km';
                    bearing = Math.round(calculateBearing(prev, latLng)) + '°';
                }
                csv += `${i + 1},"${coord}",${distance},${bearing}\n`;
            }
        }

        // Add total distance line
        const totalText = document.getElementById('totalDistance').textContent.replace('Total Distance: ', '');
        csv += `\nTotal Distance,${totalText}\n`;

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'route.csv';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
    }

    // Haversine function to calculate distance between two points
    function haversine2(point1, point2) {
        const R = 6371; // Earth radius in km
        const dLat = (point2.lat - point1.lat) * Math.PI / 180;
        const dLon = (point2.lon - point1.lon) * Math.PI / 180;
        const lat1 = point1.lat * Math.PI / 180;
        const lat2 = point2.lat * Math.PI / 180;

        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1) * Math.cos(lat2) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
    }	
	
	function showHideLocationList(){
		const locationList = document.getElementById('location-list');
  
  		if (locationList.style.display=='block') {
			locationList.style.display='none'; // Show the list
		} else {
			locationList.style.display='block';  // Hide the list
		}		
		
	}
	
	
    </script>
</body>
</html>